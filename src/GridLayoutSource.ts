import {
    IItemLayout,
    LayoutSource,
    LayoutSourceProps,
    Evergrid as Grid,
} from './internal';
import { IItem, IItemUpdate, IPoint } from './types';
import {
    emptyPointRange,
    forEachInstertedPointInRange,
    isPointRangeEqual,
} from './util';

declare type T = IPoint;

export interface GridLayoutSourceProps extends LayoutSourceProps<T> {
    onVisibleRangeChange?: (
        visibleRange: [T, T],
        layoutSource: LayoutSource
    ) => void;
}

export default class GridLayoutSource extends LayoutSource<
    IPoint,
    GridLayoutSourceProps
> {
    visibleItems: { [xy: string]: IItem<T> };
    visibleRange: [T, T];
    pendingVisibleRange?: [T, T];

    constructor(props: GridLayoutSourceProps) {
        super(props);
        this.visibleItems = {};
        this.visibleRange = emptyPointRange();
    }

    getItemContentLayout(index: T): IItemLayout {
        let { itemSize: size } = this;
        return {
            offset: {
                x: index.x * size.x,
                y: index.y * size.y,
            },
            size,
        };
    }

    encodeIndex(index: T): string {
        return `${index.x},${index.y}`;
    }

    getVisibleItem(index: T): IItem<T> | undefined {
        return this.visibleItems[this.encodeIndex(index)];
    }

    setVisibleItem(index: T, item: IItem<T> | undefined) {
        let i = this.encodeIndex(index);
        if (item) {
            this.visibleItems[i] = item;
        } else {
            delete this.visibleItems[i];
        }
    }

    *itemUpdates(): Generator<IItemUpdate<T>> {
        let pendingVisibleRange = this.pendingVisibleRange;
        if (!pendingVisibleRange) {
            return;
        }
        // Hidden items
        let it = forEachInstertedPointInRange(
            pendingVisibleRange,
            this.visibleRange
        );
        for (let i of it) {
            yield { remove: i };
        }

        // Shown items
        it = forEachInstertedPointInRange(
            this.visibleRange,
            pendingVisibleRange
        );
        for (let i of it) {
            yield { add: i };
        }
    }

    *visibleIndexes(): Generator<T> {
        let [p0, pN] = this.pendingVisibleRange || this.visibleRange;
        for (let x = p0.x; x < pN.x; x++) {
            for (let y = p0.y; y < pN.y; y++) {
                yield { x, y };
            }
        }
    }

    getVisibleItemAtLocation(p: IPoint): IItem<T> | undefined {
        let i = this.getGridIndex(p, { floor: true });
        return this.getVisibleItem(i);
    }

    isEqualIndexes(i1: T, i2: T): boolean {
        return i1.x === i2.x && i1.y === i2.y;
    }

    copyIndex(index: T): T {
        return { ...index };
    }

    shouldUpdate() {
        let pendingVisibleRange = this.getVisibleGridIndexRange();
        return !isPointRangeEqual(pendingVisibleRange, this.visibleRange);
    }

    didBeginUpdate() {
        super.didBeginUpdate();
        this.pendingVisibleRange = this.getVisibleGridIndexRange();
        // console.debug(`[${this.id}] visible items: ${Object.keys(this.visibleItems).length} (ok: ${Object.values(this.visibleItems).filter(item => !!item.ref?.current).length})`);
        // console.debug(`[${this.id}] currentVisibleRange: ` + JSON.stringify(this.visibleRange));
        // console.debug(`[${this.id}] pendingVisibleRange: ` + JSON.stringify(this.pendingVisibleRange));
    }

    didEndUpdate() {
        let pendingVisibleRange = this.pendingVisibleRange;
        if (pendingVisibleRange) {
            this.visibleRange = pendingVisibleRange;
        }
        super.didEndUpdate();
        if (pendingVisibleRange) {
            this.props.onVisibleRangeChange?.(pendingVisibleRange, this);
        }
    }
}
